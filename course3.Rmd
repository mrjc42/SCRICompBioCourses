---
title: "Coding with R"
author: "Marc, Sean, Bronson and Debbie"
date: "11/25/2015"
output: html_document
---

Welcome to our third course which aims to take you from a basic ability to interact with the language to one where you are able to write your own code.  From the outset we will try to warn you about bad habits so that you will avoid making some of the mistakes that most other people make when they start programming in R.

Here is a list of topics that should be covered by the end of this course:

# Basic system tools
One of the useful parts of R is how it can interact directly with the OS that you have installed it on.  R can see what is in your local filesystem, it knows what kind of an OS you are running, and how to point the file separators.  And it can even launch command line tools right from R.  However, using these abilities can come at the cost of platform independence (the ability of your R scripts to be portable to other platforms).  So you should use these powers judiciously.

### `getwd`, `setwd`

The most basic R file system utility is probably `getwd` or "get working directory" function.  It means the same thing as the unix `pwd` command, except that instead of telling you where you are, it tells you where R is working from at the time.  If you don't like where R has defaulted to, you can use the `setwd` command to set the directory to something else.


### `dir`, `file.remove`, `file.rename`

R has a family of functions for basic file management.  `dir` will let you list the contents of a directory, `file.remove` will let you remove a file from the file system and `file.rename` will let you rename OR move a file to another location (whether you name it something new or not).


### The powerful (system dependent) `system` command:

One of the most complicated and powerful of R's basic utilities is the `system` command.  This will run any command line commands based on the interpretation of a string that you pass in.  This is obviously extremely powerful, but remember that if you use this function in a program your code will no longer work on any platform other than ones that support the exact system command that you are passing in.  So for example, the following command will only work on unix based systems:

```{r}
system('pwd')
```

### Platform independence: `.Platform$file.sep`, `file.path` and `system.file`

So how can you deal with the problem of platform independence?  There are many solutions to different problems that are created by the need to have portable R code.  One of the most common problems is: How do I read in a file when the file separators are different on different OS's?  

To learn what the current OS is using as a file separator, you can look at the path.sep portion of the .Plaform object like this:
```{r}
.Platform$file.sep
```

Alternatively, maybe you have set things up so that you always have file 'bar.txt' that is contained inside of a 'foo' directory.  If that is the case you can always generate the correctly formatted file path by using the `file.path` function:

```{r}
file.path('foo','bar.txt')
```

Finally, if you have a file that is stored in an installed package, the `system.file` command is an ideal way to refer to resources like this (in a way that respects whatever OS you are using).




# How to create basic functions

Now we are ready to introduce the tools for how to write basic functions.  The good news is that writing functions is easy.  The bad news is that writing great functions takes practice.  Here we will introduce you to the basics and then we will give you some tips so that you can write useful functions.

### The basics

The first thing to understand about writing functions is that in R, there is a special function called `function` that is used to create a function.  Lets look at a simple example that defines a function called `myFun`. 

```{r}
myFun <- function(){}
```

And that's it.  You can now call the function `myFun` just like this:

```{r}
myFun()
```

But you may have noticed that myFun() is not very interesting since it doesn't actually do anything...  To fix that, we can put some instructions inside of the curly braces that follow the call to `function` like this:

```{r}
myFun <- function(){1+2}
myFun()
```

So that is at least more interesting.  But what if we wanted to pass in a value to our function?  Well we could define a function argument just by putting it into the function call to `function`, and then referring to that argument insid of the curly braces.  That would look like this:

```{r}
myFun <- function(x,y){x+y}
myFun(x=2, y=3)
```

And if we wanted to get fancy, we could even define some default arguments for our function like so:

```{r}
myFun <- function(x=1,y=2){x+y}
myFun(2)
```


***
####  <span style="color:blue">__Exercise R1:__</span> 

TODO: Question about system

TODO: Question about functions


***



# Flow control

Basic function creation is pretty straightforward, but what if we want to apply some logic inside of our function?  

### `=` vs `==`

You have already  seen the `=` operator before and know that in most (but not all) cases it acts as an assinment operator.  Now lets meed the `==`.  The `==` operator tests equality.  It returns a boolean value (TRUE or FALSE), depending on what the expression is.  So for example lets look at a couple of uses of this new operator and see what comes back:

```{r}
2==2
## VS
1==2
```

That seems pretty clear right?


But addition to `==`, there are also a lot of other operators that test equality in various ways.  Please also consider:

 operator          what it tests
----------    -----------------------
   ==           equality
   !=           not equal
   >            greater than
   <            less than
   >=           greater or equal
   <=           less than or equal
 
 
 
### `if`

But what if you need to do something different based on the results of something like an equality test (something that returns TRUE or FALSE)? In that case, we might want to use an `if` statement.  In R, an if statement is actually just another function call similar to the  `function` function.  So in R, an `if` statement usually looks like this:

```{r}
y <- 1
if(y==1){y<-pi}
y
```

Notice how the value for y was tested and then how it was set to a new value inside of the curly braces?  You can use `if` statements wherever it's convenient for you.  But most people find them most useful when you need a function to make a decision.


### `else`

Often times when you are done with an `if` statement you might need to do something 'else' in the event that the initial criteria was not met.  When that is true, you can use an `else` statement.  The `else` should always follow right after the results from the `if` statement like so:

```{r}
y <- 3
if(y==1){
  y<-pi
}else{
  y<-pi*2
}
y
```



### `switch`

Sometimes you might need to evaluate a whole slew of different expressions.  The `switch` function can let you handle these cases and they are _much_ more compact than a tall stack of `if` expressions would be.  But take heed: for needing this function can often be a 'red flag' concerning the design of your code.  If you have a large number of different specific expressions to handle: that often means that you are committing to maintaining a list of flags and the specific results from those flags.  `switch` statements are easy to write, but they can become a fair amount of work to maintain in the long run.  The help page for the switch function gives a pretty clear example:

```{r}
centre <- function(x, type) {
  switch(type,
         mean = mean(x),
         median = median(x),
         trimmed = mean(x, trim = .1))
}
x <- rcauchy(10)
centre(x, "mean")
centre(x, "median")
```




# Loops in R

One of the most useful applications of any programming languages is getting computers to do repetitive tasks for us and R is no exception.  For most languages this would mean that you would want to use a for loop.  R has for loops, and we will get to those in a minute.  But for a data centric language like R, repetition usually means iterating over elements of one of the many data objects that are provided.  For these kinds of tasks, there is a whole family of functions that are useful.  These functions are the `apply` family of functions.  Lets talk about a few of the more commonly used ones here:  

### `lapply` 

The `lapply` function is used to loop across a `list` or a list like object such as a `vector`.  The return value of lapply is always going to be a list.  Lets consider the following list object:

```{r}
x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
x
```

Using `lapply`, we could compute the mean of each list element like this:
```{r}
lapply(x, mean)
```

### The `apply` function

The `apply` function is used for looping across matrices.  You use it a little bit like `lapply`, but in addition to the object and function to apply, you will need to indicate which axis you want to iterate across (columns or rows).  For an example of `apply`, consider the following matrix

```{r}
x <- cbind(x1 = c(3,4,1,5), x2 = c(9,7,6,2))
x
```

And this is how you can sort the columns of x:
```{r}
apply(x, 2, sort)
```


### `mapply`

Sometimes you have a function that expects a few arguments and you need to supply them as a pair of vectors of equal length.  `mapply` lets you accomodate as many different values as your function needs. The first argument for mapply is the function followed by a `...` argument for vectors with a special named arument called `MoreArgs` in the event that you need to pass other non-vectorized argumements to your function.  The `MoreArgs` argument takes a named list of other arguments.  So for example if you needed to paste together a string and a number and have them be separated by an underscore, you could do it with `mapply` like this:

```{r}
mapply(paste, 1:3, LETTERS[1:3], MoreArgs = list(sep="_"))
```


### `bplapply`

Sometimes you need to launch an apply function across multiple cores or across a cluster.  There are several tools to use for doing this.  But one of the most versatile is `bplapply`.  This function is detailed in the BiocParallel package and will allow you to leverage a wide range of different parallelization options available from R.  Parallel processing is a pretty advanced topic for a beginner course, so for now we just wanted to make you aware of this function and it's associated package documentation.


### `for` loops (for when apply is not possible)

Sometimes it just isn't convenient to use an `apply` function.  When that happens you might need to write an old fashioned `for` loop.  `for` loops in R look odd if you are from other languages.  In R, they take a format that makes them look like our previously described `function` definitions or our use of `if`.  Here is an example:

```{r}
for(i in 1:4){message('count ',i)}
```

One quick word of caution if you are going to be writing `for` loops.  In R it is very easy to write a `for` loop where with each pass you append another element to a vector or list etc.  But in general, this approach is a bad idea.  A much better idea is to prefabricate a data object of the size you will need and then to "fill in" each element as you loop along. This strategy is sometimes called 'pre-allocate and fill'.  And it's far more efficient for R because of the way that R handles copying and memory allocation.


***
####  <span style="color:blue">__Exercise R2:__</span>

TODO: Question about flow

TODO: Question about loops

***




# Writing good code
R makes it easy to write functions.  But sometimes it seems that it makes it too easy.  You will find yourself thinking this someday when you have to decipher some horribly written R function that someone passes along to you.  Far worse though, is the realization that you yourself wrote an awful function years ago and now have to translate it today.  This section will attempt to help you avoid some of the misery associated with writing poor R code by giving you a few useful tips. 

### Check your arguments when writing functions
One of the most important things to do when writing functions is to check the arguments.  You can never trust your end users to pass in the kinds of things you were thinking when you first wrote the function.  In fact, this problem is so important that a lot of the more used R functions end up with a large proportion of code at the time written just to make sure that the arguments passed in are the correct types, lengths and contain the correct kind of information.  It is much more valuable to an end user to be told early on that one of their arguments is the wrong kind of data than to silently fail and pass along bad information back to them...

### Write short functions
Always try to write functions that only do one thing.  And if you must write a function that does multiple things, it should be written so that it calls several shorter (and simpler functions).  The best functions are the ones that do one thing well.  Why?  Because a simple function is more likely to be reusable.  And it is also a lot more likely to make sense when you have to decipher what it's original purpose was three months from now.

### Don't repeat yourself (DRY principle)
Copying code is always a bad idea.  Inevitably, if you have two places in your code where the same thing is repeated, what will happen is that you will have to make a change and you will forget to keep them both in sync.  While that might be an interesting natural history experiment, it makes for a lot of engineering headaches down the road.  If you ever find yourself with the same code in more than one place do yourself a favor and write a short function (then call it in those two places).

### Always check if someone else has solved the problem
Even better than writing code is to discover that someone else has already solved the problem.  Always look before you write.





# Basic debugging tools

### `system.time`

One of the common problems when writing code is working out how long something takes.  The `system.time` command will tell you this information for any function or R expression.  This is a good tool to should reach for when you need to know which part of your script is taking too long to run.  So for example, this is how you can learn how long it takes to run the `date` function.

```{r}
system.time(date())
```

### `browser`

I don't really recommend using `browswer` for actual debugging.  But it's been around long enough that if you look into debugging someone will mention it.  Now I have too!  To make use of it, you just need to insert a function call to browser() into your source code.  If that sounds inconvenient, it's because it is.  :P

### `debug` and `undebug`

Instead I recommend starting your debug adventures with the `debug` function.  This will allow you to 'look inside' a function while it runs, pausing to look at the values of local variables as it proceeds.  This function will make a call to the browser() whenever you actually step into the marked function 'as if' you had modified your code by using the `browser` function.  And when you are done, you can call `undebug` so that future calls to that function will not get launch into the debugger.

### `trace`

The one big bummer about `debug` is that it doesn't work on methods.  This would not be a problem except that a lot of functions are actually S4 methods (so `debug` won't let you look inside of these).  The `trace` method is better in the sense that it works on everything, but it's worse in the sense that you have to use several arguments to get it to help you.  So it's not as convenient as `debug`.

### Using RStudio to debug

This is pretty nice and give you access to some of the nicer debugging tools that have traditionally been missing from R.  But it is also documented elsewhere.  Using RStudio you can set breakpoints so that you can stop your code with minimal fuss.  But this has all been documented before by the RStudio team:

```
https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio
```


***
####  <span style="color:blue">__Exercise R3:__</span> 

TODO: Question with code debugging  (give them a very broken function to fix...)

***


# Literate programming.

Literate programming is the idea that a single documnent can contain both human ideas and executable machine code.  It was initially put forward by the legenadary Donald Knuth.  And it is especially valuable in fields like science and mathetics where ideas need to be reproducible and testable when shared with colleagues.  Over the years there have been several attempts to make this workable and they have seen varying degrees of success, but one of the most useable and successful applications o fthis is the R markdown (.Rmd) document.

### What is an .Rmd file?

An R markdown (.Rmd) document allows you to embed R code right into the middle of your english prose.  You can make one right from your RStudio session by simply choosing it from the File menu.  The mardown is extremely simple and easy to learn.  But for a fullly detailed description of all advanced features, be sure to have a look at this document here: 
```{bash, eval=FALSE}
http://rmarkdown.rstudio.com/
```

### Reproducible research

But why would you want to do this?  Probably the best reason is that you want to know both what code you wrote and why you wrote it later on.  By documenting your code with .Rmd files, you can come back later and see both what you were thinking as well as what code you ran.  It is also a nicely explicit way of sharing workflows with colleagues who otherwise might struggle to reproduce your work.

As an example of a use case for .Rmd, all the handouts for this course were created with .Rmd documents.  Using .Rmd allowed us to run both a spelling check __and__ a code check to make sure that all the code blocks ran as expected before we went to press.

Also useful to know is that you can use .Rmd for languages other than just R.  Sure it's great for R, but you can also write code chunks that run a whole array of alternative language calls.  Have a look at this list of alternate possibilities:

```{r, echo=FALSE}
names(knitr::knit_engines$get())
```


***
####  <span style="color:blue">__Exercise R4:__</span> 

Lets start by using RStudio to create an .Rmd file.

TODO: create an Rmd and modify the code chunks.

***





# Version control.

So writing your code as .Rmd files will go a long ways towards helping you compose your ideas so that things can be tested easily.  But what if you have a lot of R code and you are making a lot of changes?  How will you keep track of what has changed?  And if you work on a piece of code with a co-worker?  How will you both be able to work on it without losing your minds?

The answer is to use version control software.  Version control softare is something that all software developers use, and it's very much worth your time to learn to use it too.  It's not difficult to learn, but if you make good use of it, it can not only save your bacon, but it can make your life a lot easier as well.  There have been many popular flavors of version control software that have come out over the years.  A few you might have heard about are `rcs`, `cvs`, `svn` and more recently `git`. 










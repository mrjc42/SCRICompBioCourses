---
title: "Coding with R"
author: "Marc, Sean, Bronson and Debbie"
date: "11/25/2015"
output: html_document
---

Welcome to our third course which aims to take you from a basic ability to interact with the language to one where you are able to write your own code.  From the outset we will try to warn you about bad habits so that you will avoid making some of the mistakes that most other people make when they start programming in R.

Here is a list of topics that should be covered by the end of this course:

# Basic system tools
One of the useful parts of R is how it can interact directly with the OS that you have installed it on.  R can see what is in your local filesystem, it knows what kind of an OS you are running, and how to point the file separators.  And it can even launch command line tools right from R.  However, using these abilities can come at the cost of platform independence (the ability of your R scripts to be portable to other platforms).  So you should use these powers judiciously.

### `getwd`, `setwd`

The most basic R file system utility is probably `getwd` or "get working directory" function.  It means the same thing as the unix `pwd` command, except that instead of telling you where you are, it tells you where R is working from at the time.  If you don't like where R has defaulted to, you can use the `setwd` command to set the directory to something else.


### `dir`, `file.remove`, `file.rename`

R has a family of functions for basic file management.  `dir` will let you list the contents of a directory, `file.remove` will let you remove a file from the file system and `file.rename` will let you rename OR move a file to another location (whether you name it something new or not).


### The powerful (but problematic) `system` command:

One of the most complicated and powerful of R's basic utilities is the `system` command.  This will run any command line commands based on the interpretation of a string that you pass in.  This is obviously extremely powerful, but remember that if you use this function in a program your code will no longer work on any platform other than ones that support the exact system command that you are passing in.  So for example, the following command will only work on unix based systems:

```{r}
system('pwd')
```

### platform independence: `.Platform$file.sep`, `file.path` and `system.file`

So how can you deal with the problem of platform independence?  There are many solutions to different problems that are created by the need to have portable R code.  One of the most common problems is: How do I read in a file when the file separators are different on different OS's?  

To learn what the current OS is using as a file separator, you can look at the path.sep portion of the .Plaform object like this:
```{r}
.Platform$file.sep
```

Alternatively, maybe you have set things up so that you always have file 'bar.txt' that is contained inside of a 'foo' directory.  If that is the case you can always generate the correctly formatted file path by using the `file.path` function:

```{r}
file.path('foo','bar.txt')
```

Finally, if you have a file that is stored in an installed package, the `system.file` command is an ideal way to refer to resources like this (in a way that respects whatever OS you are using).


***
####  <span style="color:blue">__Exercise R:__</span> 
***


# Loops in R

### the apply family 
### lapply 
### mclapply
### map or mapply

### for loops (for when apply is not possible)



***
####  <span style="color:blue">__Exercise R:__</span> 
***



# How to create basic functions

Now we are ready to introduce the tools for how to write basic functions.  The good news is that writing functions is easy.  The bad news is that writing great functions takes practice.  Here we will introduce you to the basics and then we will give you some tips so that you can write useful functions.

### The basics

The first thing to understand about writing functions is that in R, there is a special function called `function` that is used to create a function.  Lets look at a simple example that defines a function called `myFun`. 

```{r}
myFun <- function(){}
```

And that's it.  You can now call the function `myFun` just like this:

```{r}
myFun()
```

But you may have noticed that myFun() is not very interesting since it doesn't actually do anything...  To fix that, we can put some instructions inside of the curly braces that follow the call to `function` like this:

```{r}
myFun <- function(){1+2}
myFun()
```

So that is at least more interesting.  But what if we wanted to pass in a value to our function?  Well we could define a function argument just by putting it into the function call to `function`, and then referring to that argument insid of the curly braces.  That would look like this:

```{r}
myFun <- function(x,y){x+y}
myFun(x=2, y=3)
```

And if we wanted to get fancy, we could even define some default arguments for our function like so:

```{r}
myFun <- function(x=1,y=2){x+y}
myFun(2)
```

### Flow control

Now all of that is pretty straightforward, but what if we want to apply some logic inside of our function?  

#### `=` vs `==`

You have already  seen the `=` operator before and know that in most (but not all) cases it acts as an assinment operator.  Now lets meed the `==`.  The `==` operator tests equality.  It returns a boolean value (TRUE or FALSE), depending on what the expression is.  So for example lets look at a couple of uses of this new operator and see what comes back:

```{r}
2==2
## VS
1==2
```

That seems pretty clear right?


But addition to `==`, there are also a lot of other operators that test equality in various ways.  Please also consider:

 operator          what it tests
----------    -----------------------
   ==           equality
   !=           not equal
   >            greater than
   <            less than
   >=           greater or equal
   <=           less than or equal
 
 
 
#### if

But what if you need to do something different based on the results of something like an equality test (something that returns TRUE or FALSE)? In that case, we might want to use an `if` statement.  In R, an if statement is actually just another function call similar to the  `function` function.  So in R, an `if` statement usually looks like this:

```{r}
y <- 1
if(y==1){y<-pi}
y
```

Notice how the value for y was tested and then how it was set to a new value inside of the curly braces?  You can use `if` statements wherever it's convenient for you.  But most people find them most useful when you need a function to make a decision.


#### else

Often times when you are done with an `if` statement you might need to do something 'else' in the event that the initial criteria was not met.  When that is true, you can use an `else` statement.  The `else` should always follow right after the results from the `if` statement like so:

```{r}
y <- 3
if(y==1){
  y<-pi
}else{
  y<-pi*2
}
y
```



#### switch

Sometimes you might need to evaluate a whole slew of different expressions.  The `switch` function can let you handle these cases and they are _much_ more compact than a tall stack of `if` expressions would be.  But take heed: for needing this function can often be a 'red flag' concerning the design of your code.  If you have a large number of different specific expressions to handle: that often means that you are committing to maintaining a list of flags and the specific results from those flags.  `switch` statements are easy to write, but they can become a fair amount of work to maintain in the long run.  The help page for the switch function gives a pretty clear example:

```{r}
centre <- function(x, type) {
  switch(type,
         mean = mean(x),
         median = median(x),
         trimmed = mean(x, trim = .1))
}
x <- rcauchy(10)
centre(x, "mean")
centre(x, "median")
```



***
####  <span style="color:blue">__Exercise R:__</span> 
***


# Writing good code in R
R makes it easy to write functions.  But sometimes it seems that it makes it too easy.  You will find yourself thinking this someday when you have to decipher some horribly written R function that someone passes along to you.  Far worse though, is the realization that you yourself wrote an awful function years ago and now have to translate it today.  This section will attempt to help you avoid some of the misery associated with writing poor R code by giving you a few useful tips. 

### check your arguments when writing functions
One of the most important things to do when writing functions is to check the arguments.  You can never trust your end users to pass in the kinds of things you were thinking when you first wrote the function.  In fact, this problem is so important that a lot of the more used R functions end up with a large proportion of code at the time written just to make sure that the arguments passed in are the correct types, lengths and contain the correct kind of information.  It is much more valuable to an end user to be told early on that one of their arguments is the wrong kind of data than to silently fail and pass along bad information back to them...

### write short functions
Always try to write functions that only do one thing.  And if you must write a function that does multiple things, it should be written so that it calls several shorter (and simpler functions).  The best functions are the ones that do one thing well.  Why?  Because a simple function is more likely to be reusable.  And it is also a lot more likely to make sense when you have to decipher what it's original purpose was three months from now.

### Don't repeat yourself (DRY)
Copying code is always a bad idea.  Inevitably, if you have two places in your code where the same thing is repeated, what will happen is that you will have to make a change and you will forget to keep them both in sync.  While that might be an interesting natural history experiment, it makes for a lot of engineering headaches down the road.  If you ever find yourself with the same code in more than one place do yourself a favor and write a short function (then call it in those two places).

### always check if someone else has solved the problem
Even better than writing code is to discover that someone else has already solved the problem.  Always look before you write.


***
####  <span style="color:blue">__Exercise R:__</span> 
***



# Basic debugging tools

### `system.time`

One of the common problems when writing code is working out how long something takes.  The `system.time` command will tell you this information for any function or R expression.  This is a good tool to should reach for when you need to know which part of your script is taking too long to run.  So for example, this is how you can learn how long it takes to run the `date` function.

```{r}
system.time(date())
```

### `browser`

I don't really recommend using `browswer` for actual debugging.  But it's been around long enough that if you look into debugging someone will mention it.  Now I have too!  To make use of it, you just need to insert a function call to browser() into your source code.  If that sounds inconvenient, it's because it is.  :P

### `debug` and `undebug`

Instead I recommend starting your debug adventures with the `debug` function.  This will allow you to 'look inside' a function while it runs, pausing to look at the values of local variables as it proceeds.  This function will make a call to the browser() whenever you actually step into the marked function 'as if' you had modified your code by using the `browser` function.  And when you are done, you can call `undebug` so that future calls to that function will not get launch into the debugger.

### `trace`

The one big bummer about `debug` is that it doesn't work on methods.  This would not be a problem except that a lot of functions are actually S4 methods (so `debug` won't let you look inside of these).  The `trace` method is better in the sense that it works on everything, but it's worse in the sense that you have to use several arguments to get it to help you.  So it's not as convenient as `debug`.

### Using RStudio to debug

This is pretty nice and give you access to some of the nicer debugging tools that have traditionally been missing from R.  But it is also documented elsewhere.  Using RStudio you can set breakpoints so that you can stop your code with minimal fuss.  But this has all been documented before by the RStudio team:

```
https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio
```


***
####  <span style="color:blue">__Exercise R:__</span> 
***


# Literate programming.
### What is an .Rmd file?
### Reproducible research

***
####  <span style="color:blue">__Exercise R:__</span> 
***


# version control.
### So you don't lose your mind

***
####  <span style="color:blue">__Exercise R:__</span> 
***



***
***
***
***


# Some pitfalls specific to R
#### forgetting to vectorize
#### the loop with a big appetite
#### hidden arguments and default behaviors [,drop=TRUE]

***
####  <span style="color:blue">__Exercise R:__</span> 
***


# Bioconductor. (kind of covered already)
### How to find good packages for your problem (biocviews)

### How to use workflows
### Fun Examples of things you can learn from workflows: (RNA-seq, chip-seq, etc.)

***
####  <span style="color:blue">__Exercise R:__</span> 
***


# How to write S4 methods (and when)
### methods are not the same thing as functions
### Why would you do this? (elegant dispatch)
### What is a Generic and when do I need to care?


# Write good packages (this is another course)
#### use your namespace (don't export everything)
#### use live code blocks and unit tests
#### use toy examples to verify that code works
 





